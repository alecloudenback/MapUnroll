var documenterSearchIndex = {"docs":
[{"location":"#MapUnroll","page":"Home","title":"MapUnroll","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MapUnroll.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#MapUnroll.@unroll-Tuple{Int64, Any}","page":"Home","title":"MapUnroll.@unroll","text":"@unroll N for_loop\n\nUnroll the first N iterations of a for loop, with remaining iterations handled by a regular loop.\n\nThis macro takes a for loop and explicitly expands the first N iterations, which can improve  performance and type stability, particularly when building collections where the first few  iterations determine the container's type.\n\nArguments\n\nN::Int: Number of loop iterations to unroll (must be a compile-time constant)\nfor_loop: A standard for loop expression\n\nHow it works\n\nThe macro transforms:\n\n@unroll 2 for i in 1:n\n    # body\nend\n\ninto code that is roughly equivalent to:\n\nlet\n    itr = 1:n\n    next = iterate(itr)\n\n    # First iteration (unrolled)\n    if next === nothing\n        @goto loopend\n    end\n    i, state = next\n    # body\n    next = iterate(itr, state)\n\n    # Second iteration (unrolled)\n    if next === nothing\n        @goto loopend\n    end\n    i, state = next\n    # body\n    next = iterate(itr, state)\n\n    # Remaining iterations in a while loop\n    while next !== nothing\n        i, state = next\n        # body\n        next = iterate(itr, state)\n    end\n\n    @label loopend\nend\n\nBy explicitly writing out the first few iterations, the Julia compiler can often infer the types of variables created within the loop body. This is especially beneficial when building a collection (e.g., an array of results), as the type of the collection can be determined from the first element(s), avoiding the performance cost of starting with an abstractly-typed or empty container.\n\nThe macro uses the iterate protocol directly and @goto to efficiently handle iterators that may have fewer than N elements.\n\nExample\n\nusing BangBang, MicroCollections\n\n# A function that builds a vector where the output type is not known upfront.\nfunction create_vector(n)\n    # Start with an undefined, untyped vector of a known size.\n    out = UndefVector{Union{}}(n)\n    @unroll 2 for i in 1:n\n        # The body creates a value.\n        val = i\n        # `setindex!!` from BangBang.jl will update the vector and its type.\n        # After the first iteration, `out` will become a `Vector{Int}`.\n        # The unrolling helps the compiler see this transformation and produce\n        # more specialized, faster code for the rest of the loop.\n        out = setindex!!(out, val, i)\n    end\n    return out\nend\n\n# The result is a concretely typed vector.\nv = create_vector(5)\nprintln(v)      # [1, 2, 3, 4, 5]\nprintln(typeof(v)) # Vector{Int64}\n\n\n\n\n\n","category":"macro"}]
}
